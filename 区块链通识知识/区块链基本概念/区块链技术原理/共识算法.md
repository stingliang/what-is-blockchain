<!-- 
It is written by liangrui_ibilling,
email:liangrui_ibilling@si-tech.com
-->

## 共识算法

### 为什么要共识？

区块链通过全民记账来解决信任问题，但是所有节点都参与记录数据，那么最终以谁的记录为准？或者说，怎么保证所有节点最终都记录一份相同的正确数据，即达成共识？在传统的中心化系统中，因为有权威的中心节点背书，因此可以以中心节点记录的数据为准，其他节点仅简单复制中心节点的数据即可，很容易达成共识。然而在区块链这样的去中心化系统中，并不存在中心权威节点，所有节点对等地参与到共识过程之中。由于参与的各个节点的自身状态和所处网络环境不尽相同，而交易信息的传递又需要时间，并且消息传递本身不可靠，因此，每个节点接收到的需要记录的交易内容和顺序也难以保持一致。更不用说，由于区块链中参与的节点的身份难以控制，还可能会出现恶意节点故意阻碍消息传递或者发送不一致的信息给不同节点，以干扰整个区块链系统的记账一致性，从而从中获利的情况。因此，区块链系统的记账一致性问题，或者说共识问题，是一个十分关键的问题，它关系着整个区块链系统的正确性和安全性。

### 共识算法分类

#### 工作量证明(Proof of Work, PoW)类

PoW类的共识算法主要包括区块链鼻祖比特币所采用的PoW共识及一些类似项目（如莱特币等）的变种PoW，即为大家所熟知的“挖矿”类算法。这类共识算法的核心思想实际是所有节点竞争记账权，而对于每一批次的记账（或者说，挖出一个区块）都赋予一个“难题”，要求只有能够解出这个难题的节点挖出的区块才是有效的。同时，所有节点都不断地通过试图解决难题来产生自己的区块并将自己的区块追加在现有的区块链之后，但全网络中只有最长的链才被认为是合法且正确的。

PoW类的共识算法所设计的“难题”一般都是需要节点通过进行大量的计算才能够解答的，为了保证节点愿意进行如此多的计算从而延续区块链的生长，这类系统都会给每个有效区块的生成者以一定的奖励。在比特币挖矿原理章节中展示的区块数据中，“Nonce”字段即为该区块对应难题的解，即该区块符合要求的随机数为“2355105046”。

然而不得不承认的是，PoW类算法给参与节点带来的计算开销，除了延续区块链生长外无任何其他意义，却需要耗费巨大的能源，并且该开销会随着参与的节点数目的上升而上升，是对能源的巨大浪费。

#### Po*的凭证类

鉴于PoW的缺陷，人们提出了一些PoW的替代者——Po*类算法。这类算法引入了“凭证”的概念（即Po*中的*，代表各种算法所引入的凭证类型）：根据每个节点的某些属性（拥有的币数、持币时间、可贡献的计算资源、声誉等），定义每个节点进行出块的难度或优先级，并且取凭证排序最优的节点，或是取凭证最高的小部分节点进行加权随机抽取某一节点，进行下一段时间的记账出块。这种类型的共识算法在一定程度上降低了整体的出块开销，同时能够有选择地分配出块资源，即可根据应用场景选择“凭证”的获取来源，是一个较大的改进。然而，凭证的引入提高了算法的中心化程度，一定程度上有悖于区块链“去中心化”的思想，且多数该类型的算法都未经过大规模的正确性验证实验，部分该类算法的矿工激励不够明确，节点缺乏参与该类共识的动力。

#### 拜占庭容错（ByzantineFaultTolerance, BFT）类

无论是PoW类算法还是Po*类算法，其中心思想都是将所有节点视作竞争对手，每个节点都需要进行一些计算或提供一些凭证来竞争出块的权利（以获取相应的出块好处）。BFT类算法则采取了不同的思路，它希望所有节点协同工作，通过协商的方式来产生能被所有（诚实）节点认可的区块。

具体地，BFT类共识算法一般都会定期选出一个领导者，由领导者来接收并排序区块链系统中的交易，领导者产生区块并递交给所有其他节点对区块进行验证，进而其他节点“举手”表决时接受或拒绝该领导者的提议。如果大部分节点认为当前领导者存在问题，这些节点也可以通过多轮的投票协商过程将现有领导者推翻，再以某种预先定好的协议协商产生出新的领导者节点。

<u>BFT类算法一般都有完备的安全性证明，能在算法流程上保证在群体中恶意节点数量不超过三分之一时，诚实节点的账本保持一致。然而，这类算法的协商轮次也很多，协商的通信开销也比较大，导致这类算法普遍不适用于节点数目较大的系统。业界普遍认为，BFT算法所能承受的最大节点数目不超过100。</u>